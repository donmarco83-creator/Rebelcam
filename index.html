<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Schachbrett ‚Üí FEN ‚Üí Lichess</title>
  <style>
    :root { --bg:#0b1020; --text:#e5e7eb; --muted:#94a3b8; --panel:#0b1120; --border:#1f2937; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#0b1020;color:var(--text)}
    header{padding:12px 14px;background:#111827;font-weight:700}
    main{padding:12px;max-width:980px;margin:0 auto 80px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden}
    .hd{padding:10px 12px;border-bottom:1px solid var(--border);font-weight:700;background:#0d1428}
    .bd{padding:12px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1 1 300px}

    /* Kamera-Preview */
    .video-wrap{position:relative;aspect-ratio:1/1;border-radius:12px;overflow:hidden;background:#000;cursor:pointer}
    video{width:100%;height:100%;display:block;object-fit:cover;background:#000}
    #overlay{position:absolute;inset:0;pointer-events:none;border:2px dashed rgba(255,255,255,.25)}
    #overlay .hline,#overlay .vline{position:absolute;background:rgba(255,255,255,.18)}
    #overlay .hline{left:0;right:0;height:1px;top:50%}
    #overlay .vline{top:0;bottom:0;width:1px;left:50%}

    /* Wei√üer Ring nur Optik */
    .shutter{position:absolute;left:50%;bottom:14px;transform:translateX(-50%);width:72px;height:72px;border-radius:50%;
      background:transparent;border:none;padding:0;display:grid;place-items:center;pointer-events:none}
    .shutter-inner{width:72px;height:72px;border-radius:50%;border:5px solid rgba(255,255,255,.95);box-shadow:0 6px 24px rgba(0,0,0,.45);background:transparent;pointer-events:none}

    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#1e3a8a;color:#fff;cursor:pointer}
    button.ghost{background:#374151}
    button.ok{background:#059669;border-color:#04684e}
    select,input[type="range"]{padding:10px;border-radius:10px;border:1px solid var(--border);background:#0b1120;color:#e5e7eb}
    label.slider{display:flex;align-items:center;gap:10px}
    p#status{color:var(--muted);margin:8px 0 0 0}
    .warn{margin-top:8px;padding:10px;border-radius:10px;background:#402e2e;border:1px solid #7f1d1d;color:#fecaca;display:none}

    /* Foto & Griffpunkte */
    .canvasWrap{position:relative;display:inline-block;max-width:100%;border-radius:12px;overflow:hidden;border:1px solid var(--border)}
    .canvasWrap canvas{display:block;width:100%;height:auto;background:#000}
    .handle{position:absolute;width:22px;height:22px;border-radius:50%;background:#fff;border:3px solid #2563eb;box-shadow:0 8px 20px rgba(0,0,0,.4);
      transform:translate(-50%,-50%);touch-action:none}

    /* Warp + Overlay */
    .previewStack{position:relative;max-width:820px;margin:auto}
    #warpPreview{width:100%;height:auto;display:block;background:#000;border:1px solid var(--border);border-radius:12px}
    #anno{position:absolute; inset:0; width:100%; height:100%; pointer-events:auto;}

    /* Palette */
    .palette{display:flex;flex-wrap:wrap;gap:6px}
    .pieceBtn{font-size:20px;line-height:1;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0f172a;color:#fff;cursor:pointer}
    .pieceBtn.active{outline:2px solid #60a5fa}
    .small{font-size:14px}
    .util{display:flex;flex-wrap:wrap;gap:8px}
    .util a{color:#93c5fd}
  </style>
</head>
<body>
<header>‚ôüÔ∏è Schachbrett ‚Üí FEN ‚Üí Lichess (Kamera & Analyse)</header>
<main>

  <!-- 1) Foto aufnehmen -->
  <section class="card">
    <div class="hd">1) Foto aufnehmen</div>
    <div class="bd">
      <div class="row">
        <div class="grow">
          <div class="video-wrap" id="videoWrap" title="Zum Ausl√∂sen ins Bild tippen">
            <video id="video" playsinline autoplay muted></video>
            <div id="overlay"><div class="hline"></div><div class="vline"></div></div>
            <div class="shutter"><span class="shutter-inner"></span></div>
          </div>
          <div class="controls" style="margin-top:10px;">
            <button id="btnStart">Kamera Start</button>
            <select id="cameraSelect" title="Kamera w√§hlen"></select>
            <button id="btnShoot">üì∏ Brett fotografieren</button>
          </div>
          <p id="status">Tippe ins Vorschaubild, um ein Foto zu machen.</p>
          <div id="diag" class="warn"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- 2) Ecken setzen -->
  <section class="card" style="margin-top:12px;">
    <div class="hd">2) Ecken setzen & entzerren</div>
    <div class="bd">
      <div class="canvasWrap" id="photoWrap" style="max-width:720px;margin:auto;">
        <canvas id="photoCanvas"></canvas>
        <div class="handle" id="h0"></div>
        <div class="handle" id="h1"></div>
        <div class="handle" id="h2"></div>
        <div class="handle" id="h3"></div>
      </div>
      <div class="controls" style="margin-top:10px;">
        <button id="btnWarp" class="ok">Brett entzerren</button>
        <button id="btnResetCorners" class="ghost">Ecken zur√ºcksetzen</button>
        <button id="btnRotL" class="ghost">‚Ü∂ 90¬∞</button>
        <button id="btnRotR" class="ghost">‚Ü∑ 90¬∞</button>
        <button id="btnAutoPro" class="ghost">Ecken auto (innen)</button>
        <button id="btnSnapRect" class="ghost">Snap 90¬∞</button>
      </div>
    </div>
  </section>

  <!-- 3) Warp-Vorschau + Regler -->
  <section class="card" style="margin-top:12px;">
    <div class="hd">3) Warp-Vorschau (mit Gitternetz & Reglern)</div>
    <div class="bd">
      <div class="controls" style="margin-bottom:10px">
        <label class="slider">Helligkeit <input id="rngBright" type="range" min="-50" max="50" value="0" step="1"><span id="lblBright">0</span></label>
        <label class="slider">Kontrast <input id="rngContrast" type="range" min="-50" max="50" value="0" step="1"><span id="lblContrast">0</span></label>
        <button id="btnAutoOrient" class="ghost">Auto drehen: Wei√ü unten rechts</button>
        <label style="display:inline-flex;align-items:center;gap:8px;margin-left:auto;">
          <input type="checkbox" id="toggleGrid" checked> Gitternetz
        </label>
      </div>
      <div class="previewStack">
        <canvas id="warpPreview" width="800" height="800"></canvas>
        <canvas id="anno" width="800" height="800"></canvas>
      </div>
      <div class="util" style="margin-top:10px;">
        <button id="btnRetake" class="ghost">üîÅ Neu aufnehmen</button>
        <button id="btnSaveImage" class="ghost">üíæ Bild speichern</button>
        <button id="btnShareImage" class="ghost">üì§ Teilen</button>
      </div>
    </div>
  </section>

  <!-- 4) FEN-Erkennung & Lichess -->
  <section class="card" style="margin-top:12px;">
    <div class="hd">4) Erkennung ‚Üí FEN ‚Üí Lichess</div>
    <div class="bd">
      <div class="controls" style="margin-bottom:10px;">
        <button id="btnDetect" class="ok">üîé Stellung erkennen</button>
        <button id="btnResetPred" class="ghost">‚ü≤ Erkennung √ºbernehmen</button>
        <button id="btnClear" class="ghost">‚ê° Brett leeren</button>
        <button id="btnCopyFEN">üìã FEN kopieren</button>
        <button id="btnLichess">‚ôüÔ∏è In Lichess √∂ffnen</button>
      </div>

      <div class="palette" id="palette">
        <div class="pieceBtn small" data-piece="">‚ê° Leer</div>
        <div class="pieceBtn" data-piece="P">‚ôô</div>
        <div class="pieceBtn" data-piece="N">‚ôò</div>
        <div class="pieceBtn" data-piece="B">‚ôó</div>
        <div class="pieceBtn" data-piece="R">‚ôñ</div>
        <div class="pieceBtn" data-piece="Q">‚ôï</div>
        <div class="pieceBtn" data-piece="K">‚ôî</div>
        <div class="pieceBtn" data-piece="p">‚ôü</div>
        <div class="pieceBtn" data-piece="n">‚ôû</div>
        <div class="pieceBtn" data-piece="b">‚ôù</div>
        <div class="pieceBtn" data-piece="r">‚ôú</div>
        <div class="pieceBtn" data-piece="q">‚ôõ</div>
        <div class="pieceBtn" data-piece="k">‚ôö</div>
      </div>
      <p style="color:#9ca3af;margin-top:8px">Tipp auf ein Feld setzt die gew√§hlte Figur. Doppeltipp entleert ein Feld.</p>

      <div class="row" style="margin-top:10px;">
        <div class="grow">
          <label>Erkanntes FEN</label>
          <input id="fenOut" type="text" style="width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0b1120;color:#e5e7eb" readonly />
        </div>
      </div>
    </div>
  </section>

</main>

<!-- OpenCV -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ===== DOM ===== */
const video = document.getElementById('video');
const btnStart = document.getElementById('btnStart');
const btnShoot = document.getElementById('btnShoot');
const statusEl = document.getElementById('status');
const diag = document.getElementById('diag');
const cameraSelect = document.getElementById('cameraSelect');

const photoCanvas = document.getElementById('photoCanvas');
const ctxPhoto = photoCanvas.getContext('2d');
const handles = [0,1,2,3].map(i => document.getElementById('h'+i));

const btnWarp = document.getElementById('btnWarp');
const btnResetCorners = document.getElementById('btnResetCorners');
const btnRotL = document.getElementById('btnRotL');
const btnRotR = document.getElementById('btnRotR');
const btnAutoPro = document.getElementById('btnAutoPro');
const btnSnapRect = document.getElementById('btnSnapRect');

const warpPreview = document.getElementById('warpPreview');
const ctxPreview = warpPreview.getContext('2d');
const anno = document.getElementById('anno');
const ctxAnno = anno.getContext('2d');

const rngBright = document.getElementById('rngBright');
const rngContrast = document.getElementById('rngContrast');
const lblBright = document.getElementById('lblBright');
const lblContrast = document.getElementById('lblContrast');
const btnAutoOrient = document.getElementById('btnAutoOrient');
const toggleGrid = document.getElementById('toggleGrid');

const btnDetect = document.getElementById('btnDetect');
const btnResetPred = document.getElementById('btnResetPred');
const btnClear = document.getElementById('btnClear');
const btnCopyFEN = document.getElementById('btnCopyFEN');
const btnLichess = document.getElementById('btnLichess');
const fenOut = document.getElementById('fenOut');

const btnRetake = document.getElementById('btnRetake');
const btnSaveImage = document.getElementById('btnSaveImage');
const btnShareImage = document.getElementById('btnShareImage');

const palette = document.getElementById('palette');
let currentTool = '';

/* ===== State ===== */
let currentStream = null;
let latestImage = null;
let warpedImage = null;
let predictedBoard = Array.from({length:8}, ()=>Array(8).fill(''));
let board = Array.from({length:8}, ()=>Array(8).fill(''));

/* ===== Helpers ===== */
const updateStatus = (msg, isErr=false)=>{ statusEl.textContent=msg; statusEl.style.color=isErr?'#f87171':'#94a3b8'; };
const showDiag = (txt)=>{ diag.style.display='block'; diag.textContent=txt; };

/* ===== Overlay-Gr√∂√üe mit Vorschau synchronisieren ===== */
function syncOverlaySize(){
  const rect = warpPreview.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  anno.style.width = rect.width+'px';
  anno.style.height= rect.height+'px';
  const needW=Math.round(rect.width*dpr), needH=Math.round(rect.height*dpr);
  if(anno.width!==needW || anno.height!==needH){ anno.width=needW; anno.height=needH; }
  ctxAnno.setTransform(dpr,0,0,dpr,0,0);
}

/* ===== Kamera ===== */
async function listCameras(){
  try{
    const devs=(await navigator.mediaDevices.enumerateDevices()).filter(d=>d.kind==='videoinput');
    cameraSelect.innerHTML='';
    devs.forEach((d,i)=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`Kamera ${i+1}`; cameraSelect.appendChild(o); });
    const env=devs.find(d=>/back|rear|environment/i.test(d.label)); if(env) cameraSelect.value=env.deviceId;
  }catch{}
}
async function startStream(deviceId){
  const msg=(t,e)=>updateStatus(t+(e?` [${e.name||''} ${e.message||''}]`:''), !!e);
  try{
    if(!navigator.mediaDevices?.getUserMedia){ msg('Browser unterst√ºtzt keinen Kamerazugriff.'); return; }
    video.setAttribute('playsinline',''); video.muted=true;
    if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; }
    const base={audio:false,video:{facingMode:{ideal:'environment'}}};
    if(deviceId) base.video.deviceId={exact:deviceId};
    const tries=[base,{audio:false,video:{facingMode:'environment'}},{audio:false,video:true}];
    let lastErr=null;
    for(const c of tries){
      try{
        const s=await navigator.mediaDevices.getUserMedia(c);
        currentStream=s; video.srcObject=s; await video.play();
        msg('Kamera aktiv ‚Äì Tippe ins Bild zum Ausl√∂sen.');
        listCameras(); return;
      }catch(e){ lastErr=e; }
    }
    msg('Kamera-Start fehlgeschlagen.', lastErr);
  }catch(e){ updateStatus('Fehler beim Start: '+(e.message||e), true); }
}
document.addEventListener('visibilitychange', async ()=>{ if(!document.hidden && currentStream && video.paused){ try{ await video.play(); }catch{} } });

/* ===== Foto (Tap-to-Shoot √ºberall) ===== */
function takeShot(){
  if(!video.videoWidth){ updateStatus('Video noch nicht bereit.', true); return; }
  const vw=video.videoWidth, vh=video.videoHeight, side=Math.min(vw,vh);
  const sx=Math.floor((vw-side)/2), sy=Math.floor((vh-side)/2);
  photoCanvas.width=side; photoCanvas.height=side;
  ctxPhoto.drawImage(video, sx,sy,side,side, 0,0,side,side);
  latestImage=new Image(); latestImage.onload=()=> placeDefaultHandles();
  latestImage.src=photoCanvas.toDataURL('image/jpeg',0.95);
  updateStatus('Foto aufgenommen. Setze die vier Ecken exakt auf die Brett-Au√üenkanten der Felder.');
}
function isUIEvent(e){ return !!(e.target.closest('button,select,label,input')); }
let shooting=false;
async function shootOnce(e){ if(e){ if(e.cancelable) e.preventDefault(); e.stopPropagation(); if(isUIEvent(e)) return; } if(shooting) return; shooting=true; try{ takeShot(); } finally{ shooting=false; } }
video.addEventListener('pointerup', shootOnce, {passive:false});
video.addEventListener('click',     shootOnce, {passive:false});
btnShoot.addEventListener('click',  shootOnce);

/* ===== Griffe / Ecken ===== */
function setHandle(i,xPx,yPx){ handles[i].style.left=(xPx/photoCanvas.width*100)+'%'; handles[i].style.top=(yPx/photoCanvas.height*100)+'%'; }
function placeDefaultHandles(){ setHandle(0,10,10); setHandle(1,photoCanvas.width-10,10); setHandle(2,photoCanvas.width-10,photoCanvas.height-10); setHandle(3,10,photoCanvas.height-10); }
function getHandlePoints(){ return handles.map(h=>{ const xPct=parseFloat(h.style.left)||0, yPct=parseFloat(h.style.top)||0; return {x:xPct/100*photoCanvas.width, y:yPct/100*photoCanvas.height}; }); }
handles.forEach(h=>{
  let dragging=false;
  const move=(clientX,clientY)=>{ const r=photoCanvas.getBoundingClientRect(); const x=Math.max(0,Math.min(r.width,clientX-r.left)); const y=Math.max(0,Math.min(r.height,clientY-r.top)); h.style.left=(x/r.width*100)+'%'; h.style.top=(y/r.height*100)+'%'; };
  h.addEventListener('mousedown', e=>{dragging=true;e.preventDefault();});
  window.addEventListener('mousemove', e=>{ if(dragging) move(e.clientX,e.clientY); });
  window.addEventListener('mouseup', ()=>dragging=false);
  h.addEventListener('touchstart', e=>{dragging=true;e.preventDefault();},{passive:false});
  window.addEventListener('touchmove', e=>{ if(!dragging) return; const t=e.touches[0]; move(t.clientX,t.clientY);},{passive:false});
  window.addEventListener('touchend', ()=>dragging=false);
});

/* ===== Auto-Ecken (au√üen) ‚Äì wie gehabt ===== */
function orderQuad(pts){ pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bot=pts.slice(2).sort((a,b)=>a.x-b.x); return [top[0],top[1],bot[1],bot[0]]; }
function scoreRect(quad){ if(!quad||quad.length!==4) return -1; const area=Math.abs(quad[0].x*quad[1].y-quad[1].x*quad[0].y+quad[1].x*quad[2].y-quad[2].x*quad[1].y+quad[2].x*quad[3].y-quad[3].x*quad[2].y+quad[3].x*quad[0].y-quad[0].x*quad[3].y)/2; const W=photoCanvas.width,H=photoCanvas.height; const areaScore=Math.min(1,area/(W*H*0.6)); const ang=(p,q,r)=>{const ux=p.x-q.x,uy=p.y-q.y,vx=r.x-q.x,vy=r.y-q.y; const d=(ux*vx+uy*vy)/Math.max(1e-6,Math.hypot(ux,uy)*Math.hypot(vx,vy)); return Math.acos(Math.max(-1,Math.min(1,d)));}; const A=[ang(quad[3],quad[0],quad[1]),ang(quad[0],quad[1],quad[2]),ang(quad[1],quad[2],quad[3]),ang(quad[2],quad[3],quad[0])]; const rightness=1-(A.reduce((s,a)=>s+Math.abs(Math.PI/2-a),0)/(4*(Math.PI/2))); return 0.5*areaScore+0.5*rightness; }
function autoCornersContour(){ const src=cv.imread(photoCanvas); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,gray,new cv.Size(5,5),0); let edges=new cv.Mat(); cv.Canny(gray,edges,60,180); let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(edges,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE); let best=null,bestScore=-1; for(let i=0;i<contours.size();i++){ const c=contours.get(i); const peri=cv.arcLength(c,true); let approx=new cv.Mat(); cv.approxPolyDP(c,approx,0.015*peri,true); if(approx.rows===4){ const pts=[]; for(let j=0;j<4;j++){ const p=approx.intPtr(j,0); pts.push({x:p[0],y:p[1]}); } const quad=orderQuad(pts); const sc=scoreRect(quad); if(sc>bestScore){ best=quad; bestScore=sc; } } approx.delete(); } src.delete(); gray.delete(); edges.delete(); contours.delete(); hier.delete(); return best; }
function autoCornersHough(){ const src=cv.imread(photoCanvas); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,gray,new cv.Size(3,3),0,0); let edges=new cv.Mat(); cv.Canny(gray,edges,60,180); let lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,80,100,12); let vertical=[],horizontal=[]; for(let i=0;i<lines.rows;i++){ const [x1,y1,x2,y2]=lines.intPtr(i,0); const ang=Math.abs(Math.atan2(y2-y1,x2-x1)*180/Math.PI); if(ang<20||ang>160) horizontal.push([x1,y1,x2,y2]); else if(Math.abs(ang-90)<20) vertical.push([x1,y1,x2,y2]); } const pick=(arr,fn)=>arr.reduce((a,b)=> fn(a,b)?b:a, arr[0]); const left  = vertical.length?  pick(vertical,(a,b)=>Math.min(b[0],b[2])<Math.min(a[0],a[2])) : null; const right = vertical.length?  pick(vertical,(a,b)=>Math.max(b[0],b[2])>Math.max(a[0],a[2])) : null; const top   = horizontal.length? pick(horizontal,(a,b)=>Math.min(b[1],b[3])<Math.min(a[1],a[3])) : null; const bottom= horizontal.length? pick(horizontal,(a,b)=>Math.max(b[1],b[3])>Math.max(a[1],a[3])) : null; const inter=(l1,l2)=>{ if(!l1||!l2) return null; const [x1,y1,x2,y2]=l1,[x3,y3,x4,y4]=l2; const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if(!den) return null; const px=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/den; const py=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/den; return {x:px,y:py}; }; let quad=null; if(left&&right&&top&&bottom){ quad=orderQuad([inter(top,left),inter(top,right),inter(bottom,right),inter(bottom,left)].filter(Boolean)); } src.delete(); gray.delete(); edges.delete(); lines.delete(); return quad; }

/* ===== Neue Helfer: Homographien & Gitterlinien im Warp (800√ó800) ===== */
function applyHomography(pt, H) {
  const x=pt.x, y=pt.y, w=H[6]*x + H[7]*y + H[8];
  return { x:(H[0]*x + H[1]*y + H[2]) / w, y:(H[3]*x + H[4]*y + H[5]) / w };
}
function matToArray33(M){ const a=M.data64F||M.data32F; return [a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]]; }
function findGridLinesInWarp(tmpCanvas){
  let src=cv.imread(tmpCanvas), gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,gray,new cv.Size(3,3),0,0);
  let edges=new cv.Mat(); cv.Canny(gray,edges,70,200);
  let lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,90,120,12);
  let v=[],h=[];
  for(let i=0;i<lines.rows;i++){ const [x1,y1,x2,y2]=lines.intPtr(i,0); const ang=Math.abs(Math.atan2(y2-y1,x2-x1)*180/Math.PI);
    if(ang<12||ang>168){ h.push((y1+y2)/2); } else if(Math.abs(ang-90)<12){ v.push((x1+x2)/2); } }
  const cluster=(arr,tol=12)=>{ arr.sort((a,b)=>a-b); const out=[]; for(const val of arr){ if(!out.length||Math.abs(val-out[out.length-1].mean)>tol){ out.push({sum:val,count:1,mean:val}); } else { const c=out[out.length-1]; c.sum+=val; c.count++; c.mean=c.sum/c.count; } } return out.map(c=>c.mean); };
  v=cluster(v); h=cluster(h);
  const pick=(arr,target)=>arr.length?arr.reduce((b,a)=>Math.abs(a-target)<Math.abs(b-target)?a:b,arr[0]):target;
  const left  = pick(v.filter(x=>x>40&&x<200),100);
  const right = pick(v.filter(x=>x>600&&x<760),700);
  const top   = pick(h.filter(y=>y>40&&y<200),100);
  const bottom= pick(h.filter(y=>y>600&&y<760),700);
  src.delete(); gray.delete(); edges.delete(); lines.delete();
  return {left,right,top,bottom};
}
function autoCornersInnerFromOuterQuad(outerQuad){
  const dest=800;
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([outerQuad[0].x,outerQuad[0].y, outerQuad[1].x,outerQuad[1].y, outerQuad[2].x,outerQuad[2].y, outerQuad[3].x,outerQuad[3].y]));
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0, dest,0, dest,dest, 0,dest]));
  const H=cv.getPerspectiveTransform(srcTri,dstTri);
  const Hinv=cv.getPerspectiveTransform(dstTri,srcTri);
  const Ha=matToArray33(H), Hia=matToArray33(Hinv);
  let srcImg=cv.imread(photoCanvas), warped=new cv.Mat(); cv.warpPerspective(srcImg,warped,H,new cv.Size(dest,dest),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
  const tmp=document.createElement('canvas'); tmp.width=dest; tmp.height=dest; cv.imshow(tmp,warped);
  const {left,right,top,bottom}=findGridLinesInWarp(tmp);
  const innerTL={x:left??100, y:top??100}, innerTR={x:right??700, y:top??100}, innerBR={x:right??700, y:bottom??700}, innerBL={x:left??100, y:bottom??700};
  const tl=applyHomography(innerTL,Hia), tr=applyHomography(innerTR,Hia), br=applyHomography(innerBR,Hia), bl=applyHomography(innerBL,Hia);
  [tl,tr,br,bl].forEach((p,i)=> setHandle(i,p.x,p.y));
  srcImg.delete(); warped.delete(); srcTri.delete(); dstTri.delete(); H.delete(); Hinv.delete();
  updateStatus('Innere Ecken (a8, h8, a1, h1) automatisch gesetzt.');
}

/* ===== Auto-Ecken (innen) ‚Äì Hauptfunktion ===== */
function autoFindCornersPro(){
  try{
    const q1=autoCornersContour();
    const q2=autoCornersHough();
    const s1=scoreRect(q1), s2=scoreRect(q2);
    const outer=(s1>=s2?q1:q2);
    if(!outer){ updateStatus('Keine Brettkontur gefunden. Bitte manuell grob setzen, dann ‚ÄûSnap 90¬∞‚Äú.', true); return; }
    autoCornersInnerFromOuterQuad(outer);
  }catch(e){ updateStatus('Auto-Ecken (innen) fehlgeschlagen: '+e, true); }
}

/* ===== Snap & Rotation ===== */
function snapToOrthogonal(){ const pts=getHandlePoints(); const cx=(pts[0].x+pts[1].x+pts[2].x+pts[3].x)/4, cy=(pts[0].y+pts[1].y+pts[2].y+pts[3].y)/4;
  const w=(Math.hypot(pts[1].x-pts[0].x,pts[1].y-pts[0].y)+Math.hypot(pts[2].x-pts[3].x,pts[2].y-pts[3].y))/2;
  const h=(Math.hypot(pts[3].x-pts[0].x,pts[3].y-pts[0].y)+Math.hypot(pts[2].x-pts[1].x,pts[2].y-pts[1].y))/2;
  const halfW=w/2, halfH=h/2;
  [{x:cx-halfW,y:cy-halfH},{x:cx+halfW,y:cy-halfH},{x:cx+halfW,y:cy+halfH},{x:cx-halfW,y:cy+halfH}].forEach((p,i)=>setHandle(i,p.x,p.y));
  updateStatus('Auf 90¬∞ eingerastet.'); }
function rotatePhoto(deg){ if(!photoCanvas.width) return; const c=document.createElement('canvas'); c.width=photoCanvas.width; c.height=photoCanvas.height; const x=c.getContext('2d'); x.translate(c.width/2,c.height/2); x.rotate(deg*Math.PI/180); x.drawImage(photoCanvas,-c.width/2,-c.height/2); ctxPhoto.clearRect(0,0,photoCanvas.width,photoCanvas.height); ctxPhoto.drawImage(c,0,0); placeDefaultHandles(); }

/* ===== Entzerren + Gitternetz ===== */
function drawGrid(){ if(!toggleGrid.checked) return; const s=warpPreview.width; ctxPreview.save(); ctxPreview.strokeStyle='rgba(255,255,255,.5)'; ctxPreview.lineWidth=1; for(let i=1;i<8;i++){ const x=Math.round((s/8)*i); ctxPreview.beginPath(); ctxPreview.moveTo(x,0); ctxPreview.lineTo(x,s); ctxPreview.stroke(); ctxPreview.beginPath(); ctxPreview.moveTo(0,x); ctxPreview.lineTo(s,x); ctxPreview.stroke(); } ctxPreview.restore(); }
function warpBoard(){
  if(!photoCanvas.width){ updateStatus('Kein Bild vorhanden.', true); return; }
  try{
    const pts=getHandlePoints(), dest=800;
    const srcMat=cv.imread(photoCanvas);
    const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([pts[0].x,pts[0].y,pts[1].x,pts[1].y,pts[2].x,pts[2].y,pts[3].x,pts[3].y]));
    const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0,dest,0,dest,dest,0,dest]));
    const M=cv.getPerspectiveTransform(srcTri,dstTri);
    let dst=new cv.Mat(); cv.warpPerspective(srcMat,dst,M,new cv.Size(dest,dest),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
    warpPreview.width=dest; warpPreview.height=dest;
    const tmp=document.createElement('canvas'); tmp.width=dest; tmp.height=dest; cv.imshow(tmp,dst);
    ctxPreview.clearRect(0,0,dest,dest); ctxPreview.drawImage(tmp,0,0); drawGrid(); warpedImage=tmp;
    srcMat.delete(); srcTri.delete(); dstTri.delete(); M.delete(); dst.delete();
    syncOverlaySize(); clearOverlay(); predictedBoard=Array.from({length:8},()=>Array(8).fill('')); board=predictedBoard.map(r=>r.slice()); fenOut.value='';
    updateStatus('Brett entzerrt. Optional Regler anpassen, dann ‚ÄûStellung erkennen‚Äú.');
  }catch(e){ updateStatus('Entzerren fehlgeschlagen: '+e, true); }
}

/* ===== Auto-Orientierung ===== */
function meanBrightOfSquare(row,col,matGray){ const s=warpPreview.width, cell=Math.floor(s/8); const x=col*cell, y=row*cell, pad=Math.floor(cell*0.2); const roi=matGray.roi(new cv.Rect(x+pad,y+pad,cell-2*pad,cell-2*pad)); const m=cv.mean(roi)[0]; roi.delete(); return m; }
function autoOrientWhiteBottomRight(){
  if(!warpedImage){ updateStatus('Kein entzerrtes Bild.', true); return; }
  const rots=[0,90,180,270]; let best=0,score=-1;
  for(let i=0;i<4;i++){ const c=document.createElement('canvas'); c.width=800; c.height=800; const x=c.getContext('2d'); x.translate(400,400); x.rotate(rots[i]*Math.PI/180); x.drawImage(warpedImage,-400,-400);
    let g=cv.imread(c); cv.cvtColor(g,g,cv.COLOR_RGBA2GRAY); const s=meanBrightOfSquare(7,7,g)-meanBrightOfSquare(0,0,g); g.delete(); if(s>score){score=s;best=i;} }
  ctxPreview.clearRect(0,0,800,800); ctxPreview.save(); ctxPreview.translate(400,400); ctxPreview.rotate(rots[best]*Math.PI/180); ctxPreview.drawImage(warpedImage,-400,-400); ctxPreview.restore(); drawGrid();
  const newC=document.createElement('canvas'); newC.width=800; newC.height=800; newC.getContext('2d').drawImage(warpPreview,0,0); warpedImage=newC; syncOverlaySize(); clearOverlay();
  updateStatus('Ausrichtung gesetzt: Wei√ü unten rechts.');
}

/* ===== Regler / Preprocess ===== */
function preprocessForDetection(){ let src=cv.imread(warpedImage); let out=new cv.Mat(); src.convertTo(out,-1,1+(Number(rngContrast.value)||0)/50,(Number(rngBright.value)||0)*2.5); cv.cvtColor(out,out,cv.COLOR_RGBA2GRAY); src.delete(); return out; }

/* ===== Sehr einfache Erkennung (Farbe+Besetzung) ===== */
function detectBoard(){
  if(!warpedImage){ updateStatus('Kein entzerrtes Bild.', true); return; }
  let gray=preprocessForDetection(), lap=new cv.Mat(); cv.Laplacian(gray,lap,cv.CV_16S,3,1,0,cv.BORDER_DEFAULT); let absLap=new cv.Mat(); cv.convertScaleAbs(lap,absLap);
  const s=warpPreview.width, cell=Math.floor(s/8);
  let sumL=0,cntL=0,sumD=0,cntD=0; for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const m=meanBrightOfSquare(r,c,gray); if((r+c)%2===0){sumL+=m;cntL++;} else {sumD+=m;cntD++;}}
  const meanL=sumL/cntL, meanD=sumD/cntD;
  let guess=Array.from({length:8},()=>Array(8).fill('')), vals=[];
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const x=c*cell,y=r*cell,pad=Math.floor(cell*0.15); const roi=absLap.roi(new cv.Rect(x+pad,y+pad,cell-2*pad,cell-2*pad)); vals.push(cv.mean(roi)[0]); roi.delete(); }
  vals.sort((a,b)=>a-b); const medK=vals[Math.floor(vals.length*0.5)]||0, thrK=medK*1.6+8;
  for(let r=0;r<8;r++){ for(let c=0;c<8;c++){ const x=c*cell,y=r*cell,pad=Math.floor(cell*0.15);
      const roiK=absLap.roi(new cv.Rect(x+pad,y+pad,cell-2*pad,cell-2*pad)); const kVal=cv.mean(roiK)[0]; roiK.delete();
      const roiG=gray.roi(new cv.Rect(x+pad,y+pad,cell-2*pad,cell-2*pad)); const gVal=cv.mean(roiG)[0]; roiG.delete();
      const bg=((r+c)%2===0)?meanL:meanD; const occupied=(kVal>thrK)|| (Math.abs(gVal-bg)>12);
      if(!occupied){ guess[r][c]=''; continue; }
      const cp=Math.floor(cell*0.30); const roiC=gray.roi(new cv.Rect(x+cp,y+cp,cell-2*cp,cell-2*cp)); const cm=cv.mean(roiC)[0]; roiC.delete();
      const isWhite=cm>bg+6; guess[r][c]=isWhite?'P':'p';
  }}
  lap.delete(); absLap.delete(); gray.delete();
  predictedBoard = guess.map(r=>r.slice()); board = guess.map(r=>r.slice());
  redrawOverlay(); updateFEN(); updateStatus('Erkennung ausgef√ºhrt. Tipp ein Feld an, um zu korrigieren.');
}

/* ===== Overlay / Edit ===== */
function clearOverlay(){ ctxAnno.clearRect(0,0,anno.width,anno.height); }
function redrawOverlay(){
  syncOverlaySize();
  const s=anno.clientWidth, cell=s/8;
  ctxAnno.clearRect(0,0,anno.clientWidth,anno.clientHeight);
  ctxAnno.save(); ctxAnno.textAlign='center'; ctxAnno.textBaseline='middle'; ctxAnno.font=(cell*0.6)+'px system-ui';
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const ch=board[r][c]; if(!ch) continue; const isW=(ch===ch.toUpperCase());
    const sym={'P':'‚ôô','N':'‚ôò','B':'‚ôó','R':'‚ôñ','Q':'‚ôï','K':'‚ôî','p':'‚ôü','n':'‚ôû','b':'‚ôù','r':'‚ôú','q':'‚ôõ','k':'‚ôö'}[ch]||ch;
    ctxAnno.fillStyle=isW?'#f8fafc':'#111827'; ctxAnno.strokeStyle='rgba(0,0,0,.6)'; ctxAnno.lineWidth=2;
    const cx=c*cell+cell/2, cy=r*cell+cell/2; ctxAnno.strokeText(sym,cx,cy); ctxAnno.fillText(sym,cx,cy); }
  ctxAnno.restore();
}
function canvasToSquareCoords(x,y){ const r=anno.getBoundingClientRect(); const dx=(x-r.left)/r.width, dy=(y-r.top)/r.height; let c=Math.floor(dx*8), rr=Math.floor(dy*8); c=Math.max(0,Math.min(7,c)); rr=Math.max(0,Math.min(7,rr)); return {r:rr,c}; }
let lastTap=0;
anno.addEventListener('click', e=>{
  const now=Date.now(); const {r,c}=canvasToSquareCoords(e.clientX,e.clientY);
  if(now-lastTap<300){ board[r][c]=''; redrawOverlay(); updateFEN(); lastTap=0; return; }
  lastTap=now; board[r][c]=currentTool; redrawOverlay(); updateFEN();
});
palette.addEventListener('click', e=>{
  const btn=e.target.closest('.pieceBtn'); if(!btn) return;
  [...palette.querySelectorAll('.pieceBtn')].forEach(b=>b.classList.remove('active'));
  btn.classList.add('active'); currentTool=btn.dataset.piece;
});
document.querySelector('.pieceBtn[data-piece=""]').classList.add('active'); currentTool='';

/* ===== FEN ===== */
function boardToFEN(bd){ const rows=[]; for(let r=0;r<8;r++){ let line='', empty=0; for(let c=0;c<8;c++){ const ch=bd[r][c]; if(!ch){ empty++; } else { if(empty){ line+=String(empty); empty=0; } line+=ch; } } if(empty) line+=String(empty); rows.push(line||'8'); } return rows.join('/')+' w - - 0 1'; }
function updateFEN(){ fenOut.value=boardToFEN(board); }

/* ===== Aktionen/Buttons ===== */
function drawGridAndImage(){ ctxPreview.clearRect(0,0,warpPreview.width,warpPreview.height); ctxPreview.drawImage(warpedImage,0,0); drawGrid(); }
btnStart.addEventListener('click', ()=> startStream(cameraSelect.value||undefined));
cameraSelect.addEventListener('change', ()=> startStream(cameraSelect.value));
btnResetCorners.addEventListener('click', ()=>{ if(latestImage){ ctxPhoto.drawImage(latestImage,0,0); placeDefaultHandles(); } });
btnRotL.addEventListener('click', ()=> rotatePhoto(-90));
btnRotR.addEventListener('click', ()=> rotatePhoto(90));
btnWarp.addEventListener('click', warpBoard);
btnAutoPro.addEventListener('click', autoFindCornersPro);
btnSnapRect.addEventListener('click', snapToOrthogonal);

btnAutoOrient.addEventListener('click', ()=>{ if(!warpedImage){ updateStatus('Kein entzerrtes Bild.',true); return; } autoOrientWhiteBottomRight(); redrawOverlay(); updateFEN(); });

rngBright.addEventListener('input', ()=>{ lblBright.textContent=rngBright.value; drawGridAndImage(); redrawOverlay(); });
rngContrast.addEventListener('input', ()=>{ lblContrast.textContent=rngContrast.value; drawGridAndImage(); redrawOverlay(); });

btnDetect.addEventListener('click', ()=>{ detectBoard(); });
btnResetPred.addEventListener('click', ()=>{ board = predictedBoard.map(r=>r.slice()); redrawOverlay(); updateFEN(); });
btnClear.addEventListener('click', ()=>{ board = Array.from({length:8},()=>Array(8).fill('')); redrawOverlay(); updateFEN(); });

btnCopyFEN.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(fenOut.value||''); updateStatus('FEN kopiert.'); }catch(e){ updateStatus('Kopieren nicht m√∂glich.',true); } });
btnLichess.addEventListener('click', ()=>{ const fen=encodeURIComponent(fenOut.value||''); window.open(`https://lichess.org/analysis/fromPosition?fen=${fen}`, '_blank'); });

btnRetake.addEventListener('click', ()=>{ window.scrollTo({top:0, behavior:'smooth'}); updateStatus('Bereit zum Neuaufnehmen. Starte ggf. die Kamera.', false); });
btnSaveImage.addEventListener('click', ()=>{ if(!warpedImage){ updateStatus('Kein Bild zum Speichern.', true); return; } const a=document.createElement('a'); a.href=warpedImage.toDataURL('image/jpeg',0.95); a.download='schachbrett.jpg'; a.click(); });
btnShareImage.addEventListener('click', async ()=>{ if(!warpedImage){ updateStatus('Kein Bild zum Teilen.', true); return; } try{ const blob=await new Promise(res=>warpedImage.toBlob(res,'image/jpeg',0.95)); const file=new File([blob],'schachbrett.jpg',{type:'image/jpeg'}); if(navigator.canShare && navigator.canShare({files:[file]})){ await navigator.share({files:[file],title:'Schachbrett',text:fenOut.value}); } else { await navigator.clipboard.writeText(fenOut.value||''); updateStatus('Teilen nicht unterst√ºtzt ‚Äì FEN in Zwischenablage kopiert.'); } }catch(e){ updateStatus('Teilen abgebrochen oder nicht m√∂glich.', true); } });

window.addEventListener('resize', ()=>{ syncOverlaySize(); redrawOverlay(); });

/* ===== Init ===== */
if (location.protocol!=='https:') showDiag('Hinweis: F√ºr den Kamerazugriff ist HTTPS n√∂tig (GitHub Pages URL mit https://).');
if ('mediaDevices' in navigator){ listCameras(); }
syncOverlaySize();
</script>
</body>
</html>
