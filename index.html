<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Schachbrett ‚Üí FEN ‚Üí Lichess</title>
  <style>
    :root { --bg:#0b1020; --text:#e5e7eb; --muted:#94a3b8; --panel:#0b1120; --border:#1f2937; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#0b1020;color:var(--text)}
    header{padding:12px 14px;background:#111827;font-weight:700}
    main{padding:12px;max-width:980px;margin:0 auto 80px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden}
    .hd{padding:10px 12px;border-bottom:1px solid var(--border);font-weight:700;background:#0d1428}
    .bd{padding:12px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1 1 300px}

    .video-wrap{position:relative;aspect-ratio:1/1;border-radius:12px;overflow:hidden;background:#000;cursor:pointer}
    video{width:100%;height:100%;display:block;object-fit:cover;background:#000}
    #overlay{position:absolute;inset:0;pointer-events:none;border:2px dashed rgba(255,255,255,.25)}
    #overlay .hline,#overlay .vline{position:absolute;background:rgba(255,255,255,.18)}
    #overlay .hline{left:0;right:0;height:1px;top:50%}
    #overlay .vline{top:0;bottom:0;width:1px;left:50%}

    .shutter{position:absolute;left:50%;bottom:14px;transform:translateX(-50%);width:72px;height:72px;border-radius:50%;
      background:transparent;border:none;padding:0;display:grid;place-items:center;pointer-events:none}
    .shutter-inner{width:72px;height:72px;border-radius:50%;border:5px solid rgba(255,255,255,.95);box-shadow:0 6px 24px rgba(0,0,0,.45);background:transparent;pointer-events:none}

    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#1e3a8a;color:#fff;cursor:pointer}
    button.ghost{background:#374151}
    button.ok{background:#059669;border-color:#04684e}
    select,input[type="range"]{padding:10px;border-radius:10px;border:1px solid var(--border);background:#0b1120;color:#e5e7eb}
    label.slider{display:flex;align-items:center;gap:10px}
    p#status{color:var(--muted);margin:8px 0 0 0}
    .warn{margin-top:8px;padding:10px;border-radius:10px;background:#402e2e;border:1px solid #7f1d1d;color:#fecaca;display:none}

    .canvasWrap{position:relative;display:inline-block;max-width:100%;border-radius:12px;overflow:hidden;border:1px solid var(--border)}
    .canvasWrap canvas{display:block;width:100%;height:auto;background:#000}
    .handle{position:absolute;width:22px;height:22px;border-radius:50%;background:#fff;border:3px solid #2563eb;box-shadow:0 8px 20px rgba(0,0,0,.4);
      transform:translate(-50%,-50%);touch-action:none}

    .previewStack{position:relative;max-width:820px;margin:auto}
    #warpPreview{width:100%;height:auto;display:block;background:#000;border:1px solid var(--border);border-radius:12px}
    #anno{position:absolute; inset:0; width:100%; height:100%; pointer-events:auto;}

    .palette{display:flex;flex-wrap:wrap;gap:6px}
    .pieceBtn{font-size:20px;line-height:1;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0f172a;color:#fff;cursor:pointer}
    .pieceBtn.active{outline:2px solid #60a5fa}
    .small{font-size:14px}
    .util{display:flex;flex-wrap:wrap;gap:8px}
    .util a{color:#93c5fd}
  </style>
</head>
<body>
<header>‚ôüÔ∏è Schachbrett ‚Üí FEN ‚Üí Lichess (Kamera & Analyse)</header>
<main>

  <section class="card">
    <div class="hd">1) Foto aufnehmen</div>
    <div class="bd">
      <div class="row">
        <div class="grow">
          <div class="video-wrap" id="videoWrap" title="Zum Ausl√∂sen ins Bild tippen">
            <video id="video" playsinline autoplay muted></video>
            <div id="overlay"><div class="hline"></div><div class="vline"></div></div>
            <div class="shutter"><span class="shutter-inner"></span></div>
          </div>
          <div class="controls" style="margin-top:10px;">
            <button id="btnStart">Kamera Start</button>
            <select id="cameraSelect" title="Kamera w√§hlen"></select>
            <button id="btnShoot">üì∏ Brett fotografieren</button>
          </div>
          <p id="status">Tippe ins Vorschaubild, um ein Foto zu machen.</p>
          <div id="diag" class="warn"></div>
        </div>
      </div>
    </div>
  </section>

  <section class="card" style="margin-top:12px;">
    <div class="hd">2) Ecken setzen & entzerren</div>
    <div class="bd">
      <div class="canvasWrap" id="photoWrap" style="max-width:720px;margin:auto;">
        <canvas id="photoCanvas"></canvas>
        <div class="handle" id="h0"></div>
        <div class="handle" id="h1"></div>
        <div class="handle" id="h2"></div>
        <div class="handle" id="h3"></div>
      </div>
      <div class="controls" style="margin-top:10px;">
        <button id="btnWarp" class="ok">Brett entzerren</button>
        <button id="btnResetCorners" class="ghost">Ecken zur√ºcksetzen</button>
        <button id="btnRotL" class="ghost">‚Ü∂ 90¬∞</button>
        <button id="btnRotR" class="ghost">‚Ü∑ 90¬∞</button>
        <button id="btnAutoPro" class="ghost">Ecken auto (innen)</button>
        <button id="btnSnapRect" class="ghost">Snap 90¬∞</button>
      </div>
    </div>
  </section>

  <section class="card" style="margin-top:12px;">
    <div class="hd">3) Warp-Vorschau (mit Gitternetz & Reglern)</div>
    <div class="bd">
      <div class="controls" style="margin-bottom:10px">
        <label class="slider">Helligkeit <input id="rngBright" type="range" min="-50" max="50" value="0" step="1"><span id="lblBright">0</span></label>
        <label class="slider">Kontrast <input id="rngContrast" type="range" min="-50" max="50" value="0" step="1"><span id="lblContrast">0</span></label>
        <button id="btnAutoOrient" class="ghost">Auto drehen: Wei√ü unten rechts</button>
        <label style="display:inline-flex;align-items:center;gap:8px;margin-left:auto;">
          <input type="checkbox" id="toggleGrid" checked> Gitternetz
        </label>
        <label style="display:inline-flex;align-items:center;gap:8px;">
          <input type="checkbox" id="toggleDebug" checked> Debug-Linien
        </label>
      </div>
      <div class="previewStack">
        <canvas id="warpPreview" width="800" height="800"></canvas>
        <canvas id="anno" width="800" height="800"></canvas>
      </div>
      <div class="util" style="margin-top:10px;">
        <button id="btnRetake" class="ghost">üîÅ Neu aufnehmen</button>
        <button id="btnSaveImage" class="ghost">üíæ Bild speichern</button>
        <button id="btnShareImage" class="ghost">üì§ Teilen</button>
      </div>
    </div>
  </section>

  <section class="card" style="margin-top:12px;">
    <div class="hd">4) Erkennung ‚Üí FEN ‚Üí Lichess</div>
    <div class="bd">
      <div class="controls" style="margin-bottom:10px;">
        <button id="btnDetect" class="ok">üîé Stellung erkennen</button>
        <button id="btnResetPred" class="ghost">‚ü≤ Erkennung √ºbernehmen</button>
        <button id="btnClear" class="ghost">‚ê° Brett leeren</button>
        <button id="btnCopyFEN">üìã FEN kopieren</button>
        <button id="btnLichess">‚ôüÔ∏è In Lichess √∂ffnen</button>
      </div>

      <div class="palette" id="palette">
        <div class="pieceBtn small" data-piece="">‚ê° Leer</div>
        <div class="pieceBtn" data-piece="P">‚ôô</div>
        <div class="pieceBtn" data-piece="N">‚ôò</div>
        <div class="pieceBtn" data-piece="B">‚ôó</div>
        <div class="pieceBtn" data-piece="R">‚ôñ</div>
        <div class="pieceBtn" data-piece="Q">‚ôï</div>
        <div class="pieceBtn" data-piece="K">‚ôî</div>
        <div class="pieceBtn" data-piece="p">‚ôü</div>
        <div class="pieceBtn" data-piece="n">‚ôû</div>
        <div class="pieceBtn" data-piece="b">‚ôù</div>
        <div class="pieceBtn" data-piece="r">‚ôú</div>
        <div class="pieceBtn" data-piece="q">‚ôõ</div>
        <div class="pieceBtn" data-piece="k">‚ôö</div>
      </div>
      <p style="color:#9ca3af;margin-top:8px">Tipp auf ein Feld setzt die gew√§hlte Figur. Doppeltipp entleert ein Feld.</p>

      <div class="row" style="margin-top:10px;">
        <div class="grow">
          <label>Erkanntes FEN</label>
          <input id="fenOut" type="text" style="width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0b1120;color:#e5e7eb" readonly />
        </div>
      </div>
    </div>
  </section>

</main>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ==== DOM / State ==== */
const video=document.getElementById('video');
const btnStart=document.getElementById('btnStart');
const btnShoot=document.getElementById('btnShoot');
const cameraSelect=document.getElementById('cameraSelect');
const statusEl=document.getElementById('status');
const diag=document.getElementById('diag');

const photoCanvas=document.getElementById('photoCanvas');
const ctxPhoto=photoCanvas.getContext('2d');
const handles=[0,1,2,3].map(i=>document.getElementById('h'+i));

const btnWarp=document.getElementById('btnWarp');
const btnResetCorners=document.getElementById('btnResetCorners');
const btnRotL=document.getElementById('btnRotL');
const btnRotR=document.getElementById('btnRotR');
const btnAutoPro=document.getElementById('btnAutoPro');
const btnSnapRect=document.getElementById('btnSnapRect');

const warpPreview=document.getElementById('warpPreview');
const ctxPreview=warpPreview.getContext('2d');
const anno=document.getElementById('anno');
const ctxAnno=anno.getContext('2d');

const rngBright=document.getElementById('rngBright');
const rngContrast=document.getElementById('rngContrast');
const lblBright=document.getElementById('lblBright');
const lblContrast=document.getElementById('lblContrast');
const btnAutoOrient=document.getElementById('btnAutoOrient');
const toggleGrid=document.getElementById('toggleGrid');
const toggleDebug=document.getElementById('toggleDebug');

const btnDetect=document.getElementById('btnDetect');
const btnResetPred=document.getElementById('btnResetPred');
const btnClear=document.getElementById('btnClear');
const btnCopyFEN=document.getElementById('btnCopyFEN');
const btnLichess=document.getElementById('btnLichess');
const fenOut=document.getElementById('fenOut');

const btnRetake=document.getElementById('btnRetake');
const btnSaveImage=document.getElementById('btnSaveImage');
const btnShareImage=document.getElementById('btnShareImage');

const palette=document.getElementById('palette');
let currentTool='';

let currentStream=null, latestImage=null, warpedImage=null;
let predictedBoard=Array.from({length:8},()=>Array(8).fill(''));
let board=Array.from({length:8},()=>Array(8).fill(''));

/* ==== Helpers ==== */
const updateStatus=(m,e=false)=>{statusEl.textContent=m;statusEl.style.color=e?'#f87171':'#94a3b8';};
const showDiag=t=>{diag.style.display='block';diag.textContent=t;};
function syncOverlaySize(){const r=warpPreview.getBoundingClientRect(),d=window.devicePixelRatio||1;anno.style.width=r.width+'px';anno.style.height=r.height+'px';const w=Math.round(r.width*d),h=Math.round(r.height*d);if(anno.width!==w||anno.height!==h){anno.width=w;anno.height=h;}ctxAnno.setTransform(d,0,0,d,0,0);}

/* ==== Kamera ==== */
async function listCameras(){try{const devs=(await navigator.mediaDevices.enumerateDevices()).filter(d=>d.kind==='videoinput');cameraSelect.innerHTML='';devs.forEach((d,i)=>{const o=document.createElement('option');o.value=d.deviceId;o.textContent=d.label||`Kamera ${i+1}`;cameraSelect.appendChild(o);});const env=devs.find(d=>/back|rear|environment/i.test(d.label));if(env) cameraSelect.value=env.deviceId;}catch{}}
async function startStream(deviceId){try{if(!navigator.mediaDevices?.getUserMedia){updateStatus('Browser unterst√ºtzt keinen Kamerazugriff.',true);return;}if(currentStream){currentStream.getTracks().forEach(t=>t.stop());currentStream=null;}const base={audio:false,video:{facingMode:{ideal:'environment'}}};if(deviceId) base.video.deviceId={exact:deviceId};const tries=[base,{audio:false,video:{facingMode:'environment'}},{audio:false,video:true}];let ok=null;for(const c of tries){try{ok=await navigator.mediaDevices.getUserMedia(c);break;}catch{}}if(!ok){updateStatus('Kamera-Start fehlgeschlagen.',true);return;}video.setAttribute('playsinline','');video.muted=true;currentStream=ok;video.srcObject=ok;await video.play();updateStatus('Kamera aktiv ‚Äì Tippe ins Bild zum Ausl√∂sen.');listCameras();}catch(e){updateStatus('Fehler beim Start: '+(e.message||e),true);}}
document.addEventListener('visibilitychange',async()=>{if(!document.hidden&&currentStream&&video.paused){try{await video.play();}catch{}}});

/* ==== Foto ==== */
function takeShot(){if(!video.videoWidth){updateStatus('Video noch nicht bereit.',true);return;}const vw=video.videoWidth,vh=video.videoHeight,side=Math.min(vw,vh),sx=Math.floor((vw-side)/2),sy=Math.floor((vh-side)/2);photoCanvas.width=side;photoCanvas.height=side;ctxPhoto.drawImage(video,sx,sy,side,side,0,0,side,side);latestImage=new Image();latestImage.onload=()=>placeDefaultHandles();latestImage.src=photoCanvas.toDataURL('image/jpeg',0.95);updateStatus('Foto aufgenommen. Setze die vier Ecken exakt auf die Feld-Au√üenkanten.');}
function isUIEvent(e){return !!(e.target.closest('button,select,label,input'));}
let shooting=false;
async function shootOnce(e){if(e){if(e.cancelable)e.preventDefault();e.stopPropagation();if(isUIEvent(e))return;}if(shooting)return;shooting=true;try{takeShot();}finally{shooting=false;}}
video.addEventListener('pointerup',shootOnce,{passive:false});
video.addEventListener('click',shootOnce,{passive:false});
btnShoot.addEventListener('click',shootOnce);

/* ==== Griffe ==== */
function setHandle(i,x,y){handles[i].style.left=(x/photoCanvas.width*100)+'%';handles[i].style.top=(y/photoCanvas.height*100)+'%';}
function placeDefaultHandles(){setHandle(0,10,10);setHandle(1,photoCanvas.width-10,10);setHandle(2,photoCanvas.width-10,photoCanvas.height-10);setHandle(3,10,photoCanvas.height-10);}
function getHandlePoints(){return handles.map(h=>{const x=parseFloat(h.style.left)||0,y=parseFloat(h.style.top)||0;return{x:x/100*photoCanvas.width,y:y/100*photoCanvas.height};});}
handles.forEach(h=>{let drag=false;const mv=(cx,cy)=>{const r=photoCanvas.getBoundingClientRect();const x=Math.max(0,Math.min(r.width,cx-r.left));const y=Math.max(0,Math.min(r.height,cy-r.top));h.style.left=(x/r.width*100)+'%';h.style.top=(y/r.height*100)+'%';};h.addEventListener('mousedown',e=>{drag=true;e.preventDefault();});window.addEventListener('mousemove',e=>{if(drag)mv(e.clientX,e.clientY);});window.addEventListener('mouseup',()=>drag=false);h.addEventListener('touchstart',e=>{drag=true;e.preventDefault();},{passive:false});window.addEventListener('touchmove',e=>{if(!drag)return;const t=e.touches[0];mv(t.clientX,t.clientY);},{passive:false});window.addEventListener('touchend',()=>drag=false);});

/* ==== Geometrie-Utils ==== */
function orderQuad(pts){pts.sort((a,b)=>a.y-b.y);const t=pts.slice(0,2).sort((a,b)=>a.x-b.x);const b=pts.slice(2).sort((a,b)=>a.x-b.x);return [t[0],t[1],b[1],b[0]];}
function angle(p,q,r){const ux=p.x-q.x,uy=p.y-q.y,vx=r.x-q.x,vy=r.y-q.y;const d=(ux*vx+uy*vy)/Math.max(1e-6,Math.hypot(ux,uy)*Math.hypot(vx,vy));return Math.acos(Math.max(-1,Math.min(1,d)));}

/* Score f√ºr quadrilaterale Kontur */
function scoreRect(quad){
  if(!quad||quad.length!==4) return -1;
  const area=Math.abs(quad[0].x*quad[1].y-quad[1].x*quad[0].y+quad[1].x*quad[2].y-quad[2].x*quad[1].y+quad[2].x*quad[3].y-quad[3].x*quad[2].y+quad[3].x*quad[0].y-quad[0].x*quad[3].y)/2;
  const W=photoCanvas.width,H=photoCanvas.height;
  const areaScore=Math.min(1, area/(W*H*0.5));
  const A=[angle(quad[3],quad[0],quad[1]),angle(quad[0],quad[1],quad[2]),angle(quad[1],quad[2],quad[3]),angle(quad[2],quad[3],quad[0])];
  const rightness=1-(A.reduce((s,a)=>s+Math.abs(Math.PI/2-a),0)/(4*(Math.PI/2)));
  return 0.6*areaScore+0.4*rightness;
}

/* ===== Au√üen: robust (Contours + Hough, best of) ===== */
function outerByContours(){
  const src=cv.imread(photoCanvas);
  let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  let blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
  let thr=new cv.Mat(); cv.adaptiveThreshold(blur,thr,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY_INV,11,2);
  let kernel=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(5,5));
  cv.morphologyEx(thr,thr,cv.MORPH_CLOSE,kernel);

  let contours=new cv.MatVector(), hier=new cv.Mat();
  cv.findContours(thr,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let best=null,bScore=-1;
  for(let i=0;i<contours.size();i++){
    const c=contours.get(i), peri=cv.arcLength(c,true);
    let approx=new cv.Mat(); cv.approxPolyDP(c,approx,0.02*peri,true);
    if(approx.rows===4){
      const pts=[];for(let j=0;j<4;j++){const p=approx.intPtr(j,0);pts.push({x:p[0],y:p[1]});}
      const q=orderQuad(pts), sc=scoreRect(q);
      if(sc>bScore){bScore=sc;best=q;}
    }
    approx.delete();
  }
  [src,gray,blur,thr,kernel,contours,hier].forEach(m=>m.delete());
  return {quad:best,score:bScore};
}
function outerByHough(){
  const src=cv.imread(photoCanvas);
  let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray,gray,new cv.Size(3,3),0,0);
  let edges=new cv.Mat(); cv.Canny(gray,edges,60,180);
  let lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,80,120,20);
  const V=[],H=[];
  for(let i=0;i<lines.rows;i++){
    const [x1,y1,x2,y2]=lines.intPtr(i,0);
    const ang=Math.abs(Math.atan2(y2-y1,x2-x1)*180/Math.PI);
    if(ang<15||ang>165) H.push([x1,y1,x2,y2]);
    else if(Math.abs(ang-90)<15) V.push([x1,y1,x2,y2]);
  }
  if(V.length<2||H.length<2){[src,gray,edges,lines].forEach(m=>m.delete());return {quad:null,score:-1};}
  const vx=V.map(l=>(l[0]+l[2])/2).sort((a,b)=>a-b);
  const vy=H.map(l=>(l[1]+l[3])/2).sort((a,b)=>a-b);
  const xL=vx[0], xR=vx[vx.length-1], yT=vy[0], yB=vy[vy.length-1];
  const quad=orderQuad([{x:xL,y:yT},{x:xR,y:yT},{x:xR,y:yB},{x:xL,y:yB}]);
  [src,gray,edges,lines].forEach(m=>m.delete());
  return {quad,score:scoreRect(quad)};
}
function findOuterBoardQuad(){
  const A=outerByContours(); const B=outerByHough();
  return (A.score>=B.score?A.quad:B.quad);
}

/* ==== Homographie utils ==== */
function applyHomography(pt,H){const x=pt.x,y=pt.y,w=H[6]*x+H[7]*y+H[8];return{x:(H[0]*x+H[1]*y+H[2])/w,y:(H[3]*x+H[4]*y+H[5])/w};}
function matToArray33(M){const a=M.data64F||M.data32F;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]];}

/* ==== Innenlinien: gemeinsames Fitten von (L,R) & (T,B) mit Periodizit√§t ==== */
function findGridLinesInWarp(canvas){
  let src=cv.imread(canvas);
  let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray,gray,new cv.Size(3,3),0,0);

  let gx=new cv.Mat(), gy=new cv.Mat();
  cv.Sobel(gray,gx,cv.CV_32F,1,0,3,1,0,cv.BORDER_DEFAULT);
  cv.Sobel(gray,gy,cv.CV_32F,0,1,3,1,0,cv.BORDER_DEFAULT);
  let ax=new cv.Mat(), ay=new cv.Mat(); cv.convertScaleAbs(gx,ax); cv.convertScaleAbs(gy,ay);

  const W=src.cols,H=src.rows;
  const bandY0=Math.floor(H*0.20), bandY1=Math.floor(H*0.80);
  const bandX0=Math.floor(W*0.20), bandX1=Math.floor(W*0.80);

  const colE=new Float32Array(W);
  for(let x=0;x<W;x++){let s=0,c=0;for(let y=bandY0;y<bandY1;y+=2){s+=ax.ucharPtr(y,x)[0];c++;}colE[x]=s/Math.max(1,c);}
  const rowE=new Float32Array(H);
  for(let y=0;y<H;y++){let s=0,c=0;for(let x=bandX0;x<bandX1;x+=2){s+=ay.ucharPtr(y,x)[0];c++;}rowE[y]=s/Math.max(1,c);}

  const smooth=(arr,w=7)=>{const out=new Float32Array(arr.length),h=Math.floor(w/2);for(let i=0;i<arr.length;i++){let s=0,c=0;for(let k=-h;k<=h;k++){const j=i+k;if(j<0||j>=arr.length)continue;s+=arr[j];c++;}out[i]=s/Math.max(1,c);}return out;};
  const CE=smooth(colE,9), RE=smooth(rowE,9);

  // Bewertet ein Kandidatenpaar (a,b) mit Periodizit√§t √ºber 6 Zellen
  function scorePair(arr,a,b){
    const span=b-a; if(span<540||span>860) return -1e9; // grob 6*90..6*143
    const s=span/6; let innerSum=0, dev=0;
    for(let j=1;j<=5;j++){ const pos=a+j*s; const i=Math.round(pos);
      const y1=arr[Math.max(0,i-1)]||0, y2=arr[i]||0, y3=arr[Math.min(arr.length-1,i+1)]||0;
      const peak=y2 + 0.5*(y1+y3); innerSum+=peak;
    }
    // Gleichm√§√üigkeit: Differenzen zwischen benachbarten Feldern
    for(let j=0;j<6;j++){ const p1=a+j*s, p2=a+(j+1)*s; dev+=Math.abs((p2-p1)-s); }
    const edge = (arr[Math.round(a)]||0) + (arr[Math.round(b)]||0);
    return edge + innerSum - 0.2*dev;
  }

  // Suche L,R in festen Fenstern um 100 / 700
  function searchRange(arr, a0,a1, b0,b1){
    let best={a:100,b:700,score:-1e9};
    for(let a=a0;a<=a1;a++){
      for(let b=b0;b<=b1;b++){
        const sc=scorePair(arr,a,b);
        if(sc>best.score) best={a,b,score:sc};
      }
    }
    return best;
  }

  const vBest=searchRange(CE, 60,140, 660,740);  // links/rechts
  const hBest=searchRange(RE, 60,140, 660,740);  // oben/unten

  const left=vBest.a, right=vBest.b, top=hBest.a, bottom=hBest.b;

  // volle 9-Linien (gesnappt aus Abstand s)
  const vLines=Array.from({length:9},(_,k)=> left + (right-left)/6*k).map(x=>x);
  const hLines=Array.from({length:9},(_,k)=> top  + (bottom-top)/6*k).map(y=>y);

  src.delete(); gray.delete(); gx.delete(); gy.delete(); ax.delete(); ay.delete();
  return {left,right,top,bottom,vLines,hLines};
}

/* ==== Au√üen ‚Üí innen (setzt die 4 Griffe) ==== */
function autoCornersInnerFromOuterQuad(outerQuad){
  const dest=800;
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([outerQuad[0].x,outerQuad[0].y, outerQuad[1].x,outerQuad[1].y, outerQuad[2].x,outerQuad[2].y, outerQuad[3].x,outerQuad[3].y]));
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0, dest,0, dest,dest, 0,dest]));
  const H=cv.getPerspectiveTransform(srcTri,dstTri);
  const Hinv=cv.getPerspectiveTransform(dstTri,srcTri);
  const Hia=matToArray33(Hinv);

  let srcImg=cv.imread(photoCanvas), warped=new cv.Mat();
  cv.warpPerspective(srcImg,warped,H,new cv.Size(dest,dest),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
  const tmp=document.createElement('canvas'); tmp.width=dest; tmp.height=dest; cv.imshow(tmp,warped);

  const {left,right,top,bottom}=findGridLinesInWarp(tmp);

  const innerTL={x:left, y:top}, innerTR={x:right, y:top},
        innerBR={x:right, y:bottom}, innerBL={x:left, y:bottom};

  const tl=applyHomography(innerTL,Hia), tr=applyHomography(innerTR,Hia),
        br=applyHomography(innerBR,Hia), bl=applyHomography(innerBL,Hia);
  [tl,tr,br,bl].forEach((p,i)=> setHandle(i,p.x,p.y));

  srcImg.delete(); warped.delete(); srcTri.delete(); dstTri.delete(); H.delete(); Hinv.delete();
  updateStatus('Innere Ecken automatisch gesetzt.');
}

/* ==== Haupt-Auto-Trigger ==== */
function autoFindCornersPro(){
  try{
    const outer=findOuterBoardQuad();
    if(!outer){updateStatus('Keine Brettkontur gefunden. Bitte manuell grob setzen, dann ‚ÄûSnap 90¬∞‚Äú.',true);return;}
    autoCornersInnerFromOuterQuad(outer);
  }catch(e){updateStatus('Auto-Ecken fehlgeschlagen: '+e,true);}
}

/* ==== Snap/Rotation ==== */
function snapToOrthogonal(){const pts=getHandlePoints();const cx=(pts[0].x+pts[1].x+pts[2].x+pts[3].x)/4, cy=(pts[0].y+pts[1].y+pts[2].y+pts[3].y)/4;
  const w=(Math.hypot(pts[1].x-pts[0].x,pts[1].y-pts[0].y)+Math.hypot(pts[2].x-pts[3].x,pts[2].y-pts[3].y))/2;
  const h=(Math.hypot(pts[3].x-pts[0].x,pts[3].y-pts[0].y)+Math.hypot(pts[2].x-pts[1].x,pts[2].y-pts[1].y))/2;
  const hw=w/2, hh=h/2;[{x:cx-hw,y:cy-hh},{x:cx+hw,y:cy-hh},{x:cx+hw,y:cy+hh},{x:cx-hw,y:cy+hh}]
  .forEach((p,i)=>setHandle(i,p.x,p.y));updateStatus('Auf 90¬∞ eingerastet.');}
function rotatePhoto(deg){if(!photoCanvas.width)return;const c=document.createElement('canvas');c.width=photoCanvas.width;c.height=photoCanvas.height;const x=c.getContext('2d');x.translate(c.width/2,c.height/2);x.rotate(deg*Math.PI/180);x.drawImage(photoCanvas,-c.width/2,-c.height/2);ctxPhoto.clearRect(0,0,photoCanvas.width,photoCanvas.height);ctxPhoto.drawImage(c,0,0);placeDefaultHandles();}

/* ==== Warp & Debug-Linien ==== */
function drawGrid(){
  ctxPreview.clearRect(0,0,warpPreview.width,warpPreview.height);
  if(warpedImage) ctxPreview.drawImage(warpedImage,0,0);

  if(toggleGrid.checked){
    const s=warpPreview.width;
    ctxPreview.save();ctxPreview.strokeStyle='rgba(255,255,255,.5)';ctxPreview.lineWidth=1;
    for(let i=1;i<8;i++){const x=Math.round((s/8)*i);
      ctxPreview.beginPath();ctxPreview.moveTo(x,0);ctxPreview.lineTo(x,s);ctxPreview.stroke();
      ctxPreview.beginPath();ctxPreview.moveTo(0,x);ctxPreview.lineTo(s,x);ctxPreview.stroke();}
    ctxPreview.restore();
  }
  if(toggleDebug.checked && warpedImage){
    const {left,right,top,bottom,vLines,hLines}=findGridLinesInWarp(warpedImage);
    // gelb: alle 9
    ctxPreview.save();ctxPreview.strokeStyle='rgba(252,211,77,.55)';ctxPreview.lineWidth=1;
    vLines.forEach(x=>{ctxPreview.beginPath();ctxPreview.moveTo(x,0);ctxPreview.lineTo(x,800);ctxPreview.stroke();});
    hLines.forEach(y=>{ctxPreview.beginPath();ctxPreview.moveTo(0,y);ctxPreview.lineTo(800,y);ctxPreview.stroke();});
    ctxPreview.restore();
    // gr√ºn: die 4
    ctxPreview.save();ctxPreview.strokeStyle='rgba(16,185,129,.95)';ctxPreview.lineWidth=2;
    [[left,0,left,800],[right,0,right,800]].forEach(([x1,y1,x2,y2])=>{ctxPreview.beginPath();ctxPreview.moveTo(x1,y1);ctxPreview.lineTo(x2,y2);ctxPreview.stroke();});
    [[0,top,800,top],[0,bottom,800,bottom]].forEach(([x1,y1,x2,y2])=>{ctxPreview.beginPath();ctxPreview.moveTo(x1,y1);ctxPreview.lineTo(x2,y2);ctxPreview.stroke();});
    ctxPreview.restore();
  }
}
function warpBoard(){
  if(!photoCanvas.width){updateStatus('Kein Bild vorhanden.',true);return;}
  const pts=getHandlePoints(),dest=800;
  const srcMat=cv.imread(photoCanvas);
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([pts[0].x,pts[0].y,pts[1].x,pts[1].y,pts[2].x,pts[2].y,pts[3].x,pts[3].y]));
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0,dest,0,dest,dest,0,dest]));
  const M=cv.getPerspectiveTransform(srcTri,dstTri);
  let dst=new cv.Mat();cv.warpPerspective(srcMat,dst,M,new cv.Size(dest,dest),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
  const tmp=document.createElement('canvas');tmp.width=dest;tmp.height=dest;cv.imshow(tmp,dst);
  warpedImage=tmp; srcMat.delete();srcTri.delete();dstTri.delete();M.delete();dst.delete();
  syncOverlaySize(); clearOverlay(); predictedBoard=Array.from({length:8},()=>Array(8).fill('')); board=predictedBoard.map(r=>r.slice()); fenOut.value='';
  drawGrid(); updateStatus('Brett entzerrt. Optional Regler anpassen, dann ‚ÄûStellung erkennen‚Äú.');
}

/* ==== Auto-Orientierung ==== */
function meanBrightOfSquare(row,col,matGray){const s=warpPreview.width,cell=Math.floor(s/8);const x=col*cell,y=row*cell,p=Math.floor(cell*0.2);const roi=matGray.roi(new cv.Rect(x+p,y+p,cell-2*p,cell-2*p));const m=cv.mean(roi)[0];roi.delete();return m;}
function autoOrientWhiteBottomRight(){
  if(!warpedImage){updateStatus('Kein entzerrtes Bild.',true);return;}
  const rots=[0,90,180,270];let best=0,score=-1;
  for(let i=0;i<4;i++){const c=document.createElement('canvas');c.width=800;c.height=800;const x=c.getContext('2d');x.translate(400,400);x.rotate(rots[i]*Math.PI/180);x.drawImage(warpedImage,-400,-400);let g=cv.imread(c);cv.cvtColor(g,g,cv.COLOR_RGBA2GRAY);const s=meanBrightOfSquare(7,7,g)-meanBrightOfSquare(0,0,g);g.delete();if(s>score){score=s;best=i;}}
  const p=ctxPreview;p.clearRect(0,0,800,800);p.save();p.translate(400,400);p.rotate(rots[best]*Math.PI/180);p.drawImage(warpedImage,-400,-400);p.restore();
  const n=document.createElement('canvas');n.width=800;n.height=800;n.getContext('2d').drawImage(warpPreview,0,0);warpedImage=n;syncOverlaySize();clearOverlay();drawGrid();updateStatus('Ausrichtung gesetzt: Wei√ü unten rechts.');
}

/* ==== Erkennung (einfach) ==== */
function preprocessForDetection(){let src=cv.imread(warpedImage);let out=new cv.Mat();src.convertTo(out,-1,1+(Number(rngContrast.value)||0)/50,(Number(rngBright.value)||0)*2.5);cv.cvtColor(out,out,cv.COLOR_RGBA2GRAY);src.delete();return out;}
function detectBoard(){
  if(!warpedImage){updateStatus('Kein entzerrtes Bild.',true);return;}
  let gray=preprocessForDetection(),lap=new cv.Mat();cv.Laplacian(gray,lap,cv.CV_16S,3,1,0,cv.BORDER_DEFAULT);let absLap=new cv.Mat();cv.convertScaleAbs(lap,absLap);
  const s=warpPreview.width,cell=Math.floor(s/8);
  let sumL=0,cntL=0,sumD=0,cntD=0;for(let r=0;r<8;r++)for(let c=0;c<8;c++){const m=meanBrightOfSquare(r,c,gray);if((r+c)%2===0){sumL+=m;cntL++;}else{sumD+=m;cntD++;}}
  const meanL=sumL/cntL,meanD=sumD/cntD;
  let guess=Array.from({length:8},()=>Array(8).fill('')),vals=[];
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){const x=c*cell,y=r*cell,p=Math.floor(cell*0.15);const roi=absLap.roi(new cv.Rect(x+p,y+p,cell-2*p,cell-2*p));vals.push(cv.mean(roi)[0]);roi.delete();}
  vals.sort((a,b)=>a-b);const medK=vals[Math.floor(vals.length*0.5)]||0,thrK=medK*1.6+8;
  for(let r=0;r<8;r++){for(let c=0;c<8;c++){const x=c*cell,y=r*cell,p=Math.floor(cell*0.15);
    const roiK=absLap.roi(new cv.Rect(x+p,y+p,cell-2*p,cell-2*p));const kVal=cv.mean(roiK)[0];roiK.delete();
    const roiG=gray.roi(new cv.Rect(x+p,y+p,cell-2*p,cell-2*p));const gVal=cv.mean(roiG)[0];roiG.delete();
    const bg=((r+c)%2===0)?meanL:meanD;const occ=(kVal>thrK)||Math.abs(gVal-bg)>12;
    if(!occ){guess[r][c]='';continue;}
    const cp=Math.floor(cell*0.30);const roiC=gray.roi(new cv.Rect(x+cp,y+cp,cell-2*cp,cell-2*cp));const cm=cv.mean(roiC)[0];roiC.delete();
    guess[r][c]=(cm>bg+6)?'P':'p';
  }}
  lap.delete();absLap.delete();gray.delete();
  predictedBoard=guess.map(r=>r.slice());board=guess.map(r=>r.slice());redrawOverlay();updateFEN();updateStatus('Erkennung ausgef√ºhrt. Tipp ein Feld an, um zu korrigieren.');
}

/* ==== Overlay / Edit ==== */
function clearOverlay(){ctxAnno.clearRect(0,0,anno.width,anno.height);}
function redrawOverlay(){syncOverlaySize();const s=anno.clientWidth,cell=s/8;ctxAnno.clearRect(0,0,anno.clientWidth,anno.clientHeight);ctxAnno.save();ctxAnno.textAlign='center';ctxAnno.textBaseline='middle';ctxAnno.font=(cell*0.6)+'px system-ui';
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){const ch=board[r][c];if(!ch)continue;const isW=(ch===ch.toUpperCase());const sym={'P':'‚ôô','N':'‚ôò','B':'‚ôó','R':'‚ôñ','Q':'‚ôï','K':'‚ôî','p':'‚ôü','n':'‚ôû','b':'‚ôù','r':'‚ôú','q':'‚ôõ','k':'‚ôö'}[ch]||ch;ctxAnno.fillStyle=isW?'#f8fafc':'#111827';ctxAnno.strokeStyle='rgba(0,0,0,.6)';ctxAnno.lineWidth=2;const cx=c*cell+cell/2,cy=r*cell+cell/2;ctxAnno.strokeText(sym,cx,cy);ctxAnno.fillText(sym,cx,cy);}ctxAnno.restore();}
function canvasToSquareCoords(x,y){const r=anno.getBoundingClientRect();const dx=(x-r.left)/r.width,dy=(y-r.top)/r.height;let c=Math.floor(dx*8),rr=Math.floor(dy*8);c=Math.max(0,Math.min(7,c));rr=Math.max(0,Math.min(7,rr));return{r:rr,c};}
let lastTap=0;anno.addEventListener('click',e=>{const now=Date.now();const {r,c}=canvasToSquareCoords(e.clientX,e.clientY);if(now-lastTap<300){board[r][c]='';redrawOverlay();updateFEN();lastTap=0;return;}lastTap=now;board[r][c]=currentTool;redrawOverlay();updateFEN();});
document.querySelector('.pieceBtn[data-piece=""]').classList.add('active');currentTool='';
palette.addEventListener('click',e=>{const btn=e.target.closest('.pieceBtn');if(!btn)return;[...palette.querySelectorAll('.pieceBtn')].forEach(b=>b.classList.remove('active'));btn.classList.add('active');currentTool=btn.dataset.piece;});

/* ==== FEN ==== */
function boardToFEN(bd){const rows=[];for(let r=0;r<8;r++){let line='',n=0;for(let c=0;c<8;c++){const ch=bd[r][c];if(!ch){n++;}else{if(n){line+=String(n);n=0;}line+=ch;}}if(n)line+=String(n);rows.push(line||'8');}return rows.join('/')+' w - - 0 1';}
function updateFEN(){fenOut.value=boardToFEN(board);}

/* ==== Buttons ==== */
btnStart.addEventListener('click',()=>startStream(cameraSelect.value||undefined));
cameraSelect.addEventListener('change',()=>startStream(cameraSelect.value));
btnResetCorners.addEventListener('click',()=>{if(latestImage){ctxPhoto.drawImage(latestImage,0,0);placeDefaultHandles();}});
btnRotL.addEventListener('click',()=>rotatePhoto(-90));
btnRotR.addEventListener('click',()=>rotatePhoto(90));
btnWarp.addEventListener('click',warpBoard);
btnAutoPro.addEventListener('click',autoFindCornersPro);
btnSnapRect.addEventListener('click',snapToOrthogonal);

btnAutoOrient.addEventListener('click',()=>{if(!warpedImage){updateStatus('Kein entzerrtes Bild.',true);return;}autoOrientWhiteBottomRight();redrawOverlay();updateFEN();});

rngBright.addEventListener('input',()=>{lblBright.textContent=rngBright.value;drawGrid();});
rngContrast.addEventListener('input',()=>{lblContrast.textContent=rngContrast.value;drawGrid();});
toggleGrid.addEventListener('change',drawGrid);
toggleDebug.addEventListener('change',drawGrid);

btnDetect.addEventListener('click',()=>{detectBoard();});
btnResetPred.addEventListener('click',()=>{board=predictedBoard.map(r=>r.slice());redrawOverlay();updateFEN();});
btnClear.addEventListener('click',()=>{board=Array.from({length:8},()=>Array(8).fill(''));redrawOverlay();updateFEN();});

btnCopyFEN.addEventListener('click',async()=>{try{await navigator.clipboard.writeText(fenOut.value||'');updateStatus('FEN kopiert.');}catch{updateStatus('Kopieren nicht m√∂glich.',true);}});
btnLichess.addEventListener('click',()=>{const fen=encodeURIComponent(fenOut.value||'');window.open(`https://lichess.org/analysis/fromPosition?fen=${fen}`,'_blank');});

btnRetake.addEventListener('click',()=>{window.scrollTo({top:0,behavior:'smooth'});updateStatus('Bereit zum Neuaufnehmen. Starte ggf. die Kamera.');});
btnSaveImage.addEventListener('click',()=>{if(!warpedImage){updateStatus('Kein Bild zum Speichern.',true);return;}const a=document.createElement('a');a.href=warpedImage.toDataURL('image/jpeg',0.95);a.download='schachbrett.jpg';a.click();});
btnShareImage.addEventListener('click',async()=>{if(!warpedImage){updateStatus('Kein Bild zum Teilen.',true);return;}try{const blob=await new Promise(r=>warpedImage.toBlob(r,'image/jpeg',0.95));const file=new File([blob],'schachbrett.jpg',{type:'image/jpeg'});if(navigator.canShare&&navigator.canShare({files:[file]})){await navigator.share({files:[file],title:'Schachbrett',text:fenOut.value});}else{await navigator.clipboard.writeText(fenOut.value||'');updateStatus('Teilen nicht unterst√ºtzt ‚Äì FEN in Zwischenablage kopiert.');}}catch{updateStatus('Teilen abgebrochen oder nicht m√∂glich.',true);}});

window.addEventListener('resize',()=>{syncOverlaySize();redrawOverlay();});

/* ==== Init ==== */
if(location.protocol!=='https:') showDiag('Hinweis: F√ºr den Kamerazugriff ist HTTPS n√∂tig (https://).');
if('mediaDevices' in navigator){listCameras();}
syncOverlaySize();
</script>
</body>
</html>
